[
  {
    "path": "posts/datatable/",
    "title": "data.table",
    "description": "Importer formater et manipuler vos données: data.table vs tidyverse.",
    "author": [
      {
        "name": "Pauline Lasserre-Zuber",
        "url": "https://ourcodingclub.github.io/tutorials/datatable"
      }
    ],
    "date": "2022-06-20",
    "categories": [
      "R",
      "data.table",
      "tidyverse"
    ],
    "contents": "\r\n\r\nContents\r\nIntroduction\r\n1-IMPORT DE TABLES FORMAT LONG: readr vs fread\r\n2-CALCULS SUR LES COLONNES\r\n3-CREER UNE NOUVELLE COLONNE SELON CRITERES\r\n4-SELECTIONNER DES COLONNES\r\n5-JOINDRE DES TABLES\r\n6-EXPORTATION DE TABLE\r\n7-IMPORT DE TABLE FORMAT LARGE\r\n8-FORMATAGE DES DONNEES\r\n\r\nIntroduction\r\n\r\n\r\n\r\n\r\nPour des tables de données de taille petite et moyenne (inférieure à 1 Go ou moins d’un million d’observations), il est recommandé d’utiliser le package dplyr. Pour des tables de données de grande taille (plus de 1 Go ou plus d’un million d’observations), il est recommandé d’utiliser le package data.table\r\nUn des atouts fondamentaux de data.table est sa syntaxe compacte qui lui vaut sa rapidité: data.table ne manipule que les colonnes mentionnées dans l’opérateur […], ce qui réduit le temps de traitement des données.\r\nLa forme générale de l’opérateur […] est la suivante: DT[i, j, by]: on part du data.table DT, on sélectionne certaines lignes avec i, puis on calcule j pour chaque groupe défini par by. Si on fait un parallèle avec SQL, i correspond au WHERE, j au SELECT et by au GROUP BY. La fonction […] présente deux grands avantages: pas de préfixe DT$ pour se référer aux variables à l’intérieur de […] et sa concision.\r\nLes fonctions setDT() et as.data.table() convertissent un data.frame en data.table\r\nLes data.tables sont simplement des data.frames particuliers, donc on peut normalement leur appliquer toutes les méthodes valables pour les data.frames. En particulier, on peut utiliser avec data.table toutes les fonctions des packages habituellement associés à dplyr : stringr pour le maniement de chaînes de caractères, etc.\r\n\r\nSommaire :\r\n1. IMPORT DE TABLES FORMAT LONG: readr vs fread : setup, import table 1, import table 2, sélection des données à importer, presentation des données\r\n2. CALCULS SUR LES COLONNES : calculs par groupe selon critères, enchainer les calculs\r\n3. CREER UNE NOUVELLE COLONNE SELON CRITERES\r\n4. SELECTIONNER DES COLONNES: tydiverse, data.table\r\n5. JOINDRE DES TABLES: Rbase, tydiverse, data.table avec ou sans index\r\n6. EXPORTATION DE TABLE: Rbase, tydiverse, data.table\r\n7. IMPORT DE TABLE FORMAT LARGE: tydiverse, data.table\r\n8. FORMATAGE DES DONNEES: Rbase, tydiverse, data.table\r\n\r\n1-IMPORT DE TABLES FORMAT LONG: readr vs fread\r\nSetup\r\n\r\n\r\n# chargement des packages\r\nlibrary(readr)\r\nlibrary(dplyr)\r\nlibrary(stringr)\r\n\r\nlibrary(data.table)\r\n\r\n#localisation donnees entree\r\n#dirin<-\"C:/Users/plasserre/Documents/R_workshops/workshop_data.table/\"\r\n#setwd(dirin)\r\n\r\n\r\n\r\n\r\nImport table 1\r\n\r\n\r\n# package readr de la suite tidyverse\r\nstart.time <- Sys.time()\r\nd=read_tsv(\"ISBPS_REFSEQV2_vs_RENAN_PSEUDOV2_filtered.bam_summary.tsv\", col_names=T)\r\ntime.tidy <- Sys.time() - start.time\r\n\r\n\r\n\r\n\r\n\r\n#package data.table\r\n##info systeme:\r\nnames(s <- Sys.getenv())\r\nSys.getenv(\"NUMBER_OF_PROCESSORS\")\r\nSys.getenv(\"PROCESSOR_LEVEL\")\r\nSys.getenv(\"OMP_THREAD_LIMIT\")\r\nSys.setenv(\"OMP_THREAD_LIMIT\"=4)\r\nSys.getenv(\"OMP_THREAD_LIMIT\")\r\n\r\n\r\n##nThread=1\r\nsetDTthreads(threads=1, restore_after_fork=TRUE)\r\ngetDTthreads(verbose = getOption(\"datatable.verbose\"))\r\n\r\nstart.time <- Sys.time()\r\ndt=fread(\"ISBPS_REFSEQV2_vs_RENAN_PSEUDOV2_filtered.bam_summary.tsv\",\r\n         nThread=1, sep=\"\\t\", header=TRUE, dec=\".\", encoding = \"UTF-8\", showProgress=TRUE)\r\ntime.dt1 <- Sys.time() - start.time\r\ntime.dt1\r\ntime.tidy\r\n\r\n##nThread=4\r\nsetDTthreads(threads=6, restore_after_fork=TRUE)\r\ngetDTthreads(verbose = getOption(\"datatable.verbose\"))\r\n\r\nstart.time <- Sys.time()\r\ndt=fread(\"ISBPS_REFSEQV2_vs_RENAN_PSEUDOV2_filtered.bam_summary.tsv\", \r\n         nThread=4, sep=\"\\t\", header=TRUE, dec=\".\", encoding = \"UTF-8\", showProgress=TRUE)\r\ntime.dt4 <- Sys.time() - start.time\r\ntime.dt4\r\ntime.tidy\r\n\r\n#definition d'un deuxieme seprarteur (sep2) possible !!! :))\r\n#NB: option stringsAsFactors = TRUE peut ralentir sensiblement l’importation des donnees\r\n\r\n\r\n\r\n\r\nImport table 2\r\n\r\n\r\n#package readr de la suite tidyverse\r\nstart.time <- Sys.time()\r\nfa=read_tsv(\"Tae.Chinese_Spring.refSeqv2.1.ISBPs_fasta.txt\", col_names=F)\r\ntime.tidy <- Sys.time() - start.time\r\n\r\ncolnames(fa)=c(\"read_id\",\"seq\")\r\n\r\n#package data.table  ---> nThread \r\nstart.time <- Sys.time()\r\nfadt=fread(\"Tae.Chinese_Spring.refSeqv2.1.ISBPs_fasta.txt\",\r\n           nThread=4, sep=\"\\t\", colClasses=c(\"character\", \"character\"), header=FALSE,\r\n           encoding = \"UTF-8\", showProgress=TRUE)\r\ntime.dt4 <- Sys.time() - start.time\r\ntime.dt4\r\ntime.tidy\r\n\r\n\r\n\r\n\r\nSélection des données à importer\r\n\r\n\r\n# #package readr de la suite tidyverse\r\nstart.time <- Sys.time()\r\nd=read_tsv(\"ISBPS_REFSEQV2_vs_RENAN_PSEUDOV2_filtered.bam_summary.tsv\", col_names=T,\r\n           col_select = -\"query_length\")\r\ntime.tidy <- Sys.time() - start.time\r\n\r\n\r\n#pour selectionner des colonnes à importer: option \"clo_select\" avec ou sans -\r\n#pour importer une portion de table: option \"skip\" et \"n_max\r\n\r\n\r\n#package data.table\r\nstart.time <- Sys.time()\r\ndt=fread(\"ISBPS_REFSEQV2_vs_RENAN_PSEUDOV2_filtered.bam_summary.tsv\", \r\n         nThread=4, sep=\"\\t\", header=TRUE, dec=\".\", encoding = \"UTF-8\", showProgress=TRUE,\r\n         drop=\"query_length\")\r\ntime.dt4 <- Sys.time() - start.time\r\ntime.dt4\r\ntime.tidy\r\n\r\n#pour selectionner des colonnes à importer: option \"clo_select\" avec ou sans -\r\n#pour importer une portion de table: option \"skip\" + \"nrows\"\r\n\r\n\r\n\r\n ## Presentation des données {#presentation}\r\n\r\n\r\n#suite tidyverse\r\nd\r\nfa\r\n\r\ndf=data.frame(d)\r\nfadf=data.frame(fa)\r\ncolnames(fadt)=c(\"read_id\",\"seq\")\r\n\r\n#package data.table\r\ndt\r\nfadt\r\n\r\noptions(\"datatable.print.keys\" = TRUE, \"datatable.print.class\" = TRUE)\r\ndt\r\n\r\n\r\n\r\n\r\n2-CALCULS SUR LES COLONNES\r\nCalculs par groupe selon critères\r\n\r\n\r\n# R base\r\nstart.time <- Sys.time()\r\nhead(df)\r\naggregate(df[df[[\"alignemnt_length\"]]==150, \"mapq\"],\r\n          by=list(df[df[[\"alignemnt_length\"]]==150, \"missmatches\"]),\r\n          FUN=mean)\r\nSys.time() - start.time\r\n\r\n#suite tidyverse\r\nstart.time <- Sys.time()\r\nprint(d %>%\r\n  dplyr::filter(alignemnt_length==150)%>%\r\n  dplyr::group_by(missmatches)%>%\r\n  dplyr::summarise(mean(mapq)),\r\n  n=100)\r\nSys.time() - start.time\r\n\r\n\r\n#package data.table\r\nstart.time <- Sys.time()\r\ndt[alignemnt_length==150, mean(mapq), by = missmatches]\r\nSys.time() - start.time\r\n\r\n\r\n\r\n ## Enchainer les calculs {#arrange}\r\nDplyr utilise l’opérateur pipe %>%.\r\nAvec data.table, il suffit d’accoler les opérateurs []: dt[opération 1][opération 2][opération 3][…]\r\n\r\n\r\n#suite tidyverse\r\nprint(d %>%\r\n        dplyr::filter(alignemnt_length==150) %>%\r\n        dplyr::group_by(missmatches) %>%\r\n        dplyr::summarise(mean(mapq))%>%\r\n        arrange(`mean(mapq)`),\r\n      n=100)\r\n\r\n#package data.table\r\ndt[alignemnt_length==150, mean(mapq), by = missmatches][order(missmatches)]\r\n\r\n\r\n\r\n\r\n3-CREER UNE NOUVELLE COLONNE SELON CRITERES\r\n\r\n\r\n#suite tidyverse\r\n##dim ligne --NON-- constante, dim colonne +1 : on cree la colonne nomee \"keep\"\r\nd_filt=d %>%\r\n  filter(alignemnt_length==150 & mapq==60)%>%\r\n  mutate(keep=\"OK\")\r\nd_filt\r\n\r\n##dim ligne constante, dim colonne +1 : on cree la colonne nomee \"keep\"\r\nstart.time <- Sys.time()\r\nd=d %>%\r\n  mutate(keep=if_else(alignemnt_length==150 & mapq==60,\"OK\",\"NA\"))\r\nSys.time() - start.time\r\n\r\nd\r\n#NB: assignation necessaire\r\n\r\n\r\n#package data.table\r\n##utilise beaucoup moins de memoire vive\r\n##la fonction := s’appelle “assignation par reference”, elle peut prendre des arguments entre parentheses`:=`()\r\n\r\n##dim ligne --NON-- constante, dim colonne +1\r\ndt_filt=dt[alignemnt_length==150 & mapq==60][, keep:= \"OK\"]\r\ndt_filt\r\n\r\n##dim ligne constante, dim colonne +1\r\nstart.time <- Sys.time()\r\ndt[alignemnt_length==150 & mapq==60, keep:= \"OK\"]\r\n#NB: pas d'assignation, table modifiee par reference\r\nSys.time() - start.time\r\n\r\ndt[, keep:= \"OK\"][alignemnt_length!=150 | mapq!=60, keep:= NA]\r\n\r\n\r\n\r\n\r\n4-SELECTIONNER DES COLONNES\r\ntydiverse\r\n\r\n\r\n#suite tidyverse\r\nd%>%select(read_id, missmatches, mapq)\r\n\r\n#package data.table\r\ndt[, .(read_id, missmatches, mapq)]   #NB: .() est un alias pour \"list()\"\r\n\r\ndt[, .SD, .SDcols=c(\"read_id\", \"missmatches\", \"mapq\")] #ecriture a combiner avec lapply\r\n#SD pour Subset of Data: les colonnes listees seront aliasees par .SD avec la dimension .SDcols\r\n#et par defaut, toutes les colonnes sont traitees\r\n\r\n\r\n\r\n ## data.table {#data.table1}\r\n\r\n\r\n# \r\n\r\n\r\n\r\n\r\n5-JOINDRE DES TABLES\r\nRbase\r\n\r\n\r\n # R base\r\nstart.time <- Sys.time()\r\n#df_join=base::merge(df,fadf, by=\"read_id\", all.x=TRUE)\r\nSys.time() - start.time\r\n#####Time difference of 1.373174 mins\r\n\r\n\r\n\r\n ## tydiverse {#tidyverse2}\r\n\r\n\r\n#suite tidyverse\r\nstart.time <- Sys.time()\r\nd_join=d%>%left_join(fa)   #NB: une seule var key commune, nul besoin de preciser la var de jointure\r\n#sinon: d_join=d%>%left_join(y=fa, by=\"read_id\")\r\nSys.time() - start.time\r\n\r\n\r\n\r\n ## data.table avec ou sans index {#data.table2}\r\n\r\n\r\n#package data.table\r\n##avec merge, meme ecriture qu'avec la fonction de R base\r\n\r\nstart.time = Sys.time()\r\ndt_join=merge(dt,fadt, by=\"read_id\", all.x=T)\r\ntime.dt_sansindex = Sys.time() - start.time\r\n\r\nstart.time = Sys.time()\r\ndt_join=dt[fadt, on=\"read_id\", nomatch=NULL]\r\nSys.time() - start.time\r\n\r\n##indexation de tables: accelere les combinaisons de donnees\r\nsetkey(dt, read_id)\r\nsetkey(fadt, read_id)\r\n\r\nstart.time = Sys.time()\r\ndt_join=merge(dt,fadt, by=\"read_id\", all.x=T)\r\ntime.dt_avecindex = Sys.time() - start.time\r\ntime.dt_sansindex\r\ntime.dt_avecindex\r\n\r\nkey(dt)\r\nsetkey(dt, NULL)\r\nkey(dt)\r\n\r\n\r\n\r\n\r\n6-EXPORTATION DE TABLE\r\nRbase\r\n\r\n\r\n#R base\r\nstart.time <- Sys.time()\r\n#write.table(df_join, \"ISBP_REFSEQV2_vs_RENAN_with_FASTA.TAB\", col.names=T)\r\nSys.time() - start.time\r\n#Time difference of 1.977623 mins\r\n\r\n\r\n\r\n ## tydiverse {#tidyverse3}\r\n\r\n\r\n#suite tidyverse package readr\r\nstart.time <- Sys.time()\r\nwrite_tsv(d_join, \"ISBP_REFSEQV2_vs_RENAN_with_FASTA.TAB\", col_names=T)\r\nSys.time() - start.time  # ~20 à 30sec\r\n\r\n\r\n\r\n ## data.table {#data.table3}\r\n\r\n\r\n#package data.table\r\nstart.time <- Sys.time()\r\nfwrite(dt_join, \"ISBP_REFSEQV2_vs_RENAN_with_FASTA.TAB\", col.names=T)\r\nSys.time() - start.time  # moins de 2 secondes\r\n\r\n\r\n\r\n\r\n7-IMPORT DE TABLE FORMAT LARGE\r\ntydiverse\r\n\r\n\r\n# TRANSPOSITION \r\nmat_join=as.matrix(dt_join)\r\ndim(mat_join)\r\nhead(mat_join, n=1)\r\ncolnames(mat_join)\r\n\r\ntmat_join=as.matrix(t(mat_join))\r\ndim(tmat_join)\r\nhead(tmat_join[,c(1,2,3,4,5)], n=9)\r\ntmat_join=data.table(tmat_join)\r\n\r\nfwrite(tmat_join, \"ISBP_REFSEQV2_vs_RENAN_with_FASTA_transposed_dt.TAB\", sep=\"\\t\", col.names=F)\r\n\r\n#package readr de la suite tidyverse\r\nstart.time <- Sys.time()\r\n#d_trans=read_tsv(\"ISBP_REFSEQV2_vs_RENAN_with_FASTA_transposed_dt.TAB\", col_names=F)\r\ntime.tidy <- Sys.time() - start.time ## tres tres long\r\n\r\n\r\n\r\n ## data.table {#data.table4}\r\n\r\n\r\n#package data.table\r\nstart.time <- Sys.time()\r\ndt_trans=fread(\"ISBP_REFSEQV2_vs_RENAN_with_FASTA_transposed_dt.TAB\", \r\n         nThread=4, sep=\"\\t\", header=FALSE, dec=\".\", encoding = \"UTF-8\", showProgress=TRUE)\r\ntime.dt <- Sys.time() - start.time\r\ntime.dt # ~16 secondes\r\ntime.tidy\r\n\r\n\r\n\r\n\r\n8-FORMATAGE DES DONNEES\r\nRbase\r\n\r\n\r\n# apply()\r\n\r\n\r\n\r\n ## tydiverse {#tidyverse5}\r\n\r\n\r\n# mutate(across)\r\n\r\n\r\n\r\n ## data.table {#data.table5}\r\n\r\n\r\n# lapply .SD .SDcols\r\n\r\n\r\n\r\n\r\nRéférences UtilitR\r\n\r\n\r\n\r\n",
    "preview": "posts/datatable/img/logo_datatable.png",
    "last_modified": "2022-06-17T14:40:19+02:00",
    "input_file": {}
  },
  {
    "path": "posts/manipuler-donnees-tidyverse/",
    "title": "Manipulation de données",
    "description": "Manipuler et mettre en forme vos données à l'aide du Tidyverse.",
    "author": [
      {
        "name": "Sandra Angers-Blondin",
        "url": "https://ourcodingclub.github.io/tutorials/data-manip-intro"
      },
      {
        "name": "Jonathan Kitt (adaptation)",
        "url": {}
      }
    ],
    "date": "2022-05-20",
    "categories": [
      "R",
      "RStudio",
      "Données",
      "Tidyverse"
    ],
    "contents": "\r\n\r\nContents\r\nIntroduction\r\nManipuler des données avec dplyr\r\nMettre en forme des données à l’aide de tidyr\r\nDéfi\r\n\r\nCe tutoriel est adapté de Basic data manipulation et Efficient data manipulation du site Our Coding Club.\r\nIntroduction\r\n\r\n\r\n\r\nDessin de Allison Horst\r\n\r\nLes formats de nos données peuvent varier, et un format utile et pratique dans un cas précis ne le sera pas forcément dans un autre. La maîtrise des outils de manipulation et de mise en forme des données est donc essentielle !\r\n\r\nVoici le sommaire de ce tutoriel :\r\n\r\n1. Manipuler des données avec dplyr : renommer des variables, sélectionner des colonnes, filtrer des données, trier des données, créer de nouvelles colonnes, définir des groupes, calculer des statistiques, joindre des données\r\n2. Mettre en forme des données avec tidyr : format long, format large\r\n3. Défi\r\n\r\nVous pourrez trouver les fichiers utilisés dans ce tutoriel ainsi qu’un exemple de script en cliquant ici.\r\nVous pouvez revoir les bases de R et RStudio dans le tutoriel Premiers pas avec R.\r\n\r\nLe Tidyverse\r\nLe Tidyverse est un ensemble de packages permettant notamment d’importer des données (readr), de les manipuler (dplyr), de les mettre en forme (tidyr), de créer des graphiques (ggplot2), de manipuler des chaînes de caractères (stringr), de rédiger des rapports (rmarkdown), …\r\n\r\n\r\n\r\nDessin de Allison Horst\r\n\r\nCommençons par installer la suite Tidyverse (nous pourrions également installer séparément les packages que nous allons utiliser, dplyr et tidyr) :\r\n\r\n\r\n# Installer le Tidyverse\r\ninstall.packages(\"tidyverse\")\r\n\r\n\r\n\r\n\r\nManipuler des données avec dplyr\r\nLes fonctions du package dplyr sont nommées d’après l’action qu’elles accomplissent, ce qui rend leur utilisation assez intuitive.\r\nNous allons utiliser un jeu de données contenant des mesures de croissance annuelle de tiges d’arbrisseaux qui poussent dans des dunes de sable (Empetrum nigrum ou camarine noire). La distance à la mer de chaque individu est codée dans la variable catégorique “zone” : le chiffre 2 représente la zone la plus proche de la mer et le chiffre 7 la zone la plus éloignée de la mer.\r\nLa fonction read_csv() permet d’importer un fichier .csv depuis une page web :\r\n\r\n\r\n# Ateliers codons!\r\n# 02 - Manipulation de donnees\r\n# Lundi 30/05/2022\r\n\r\n# Charger le Tidyverse ----\r\n\r\nlibrary(tidyverse)\r\n\r\n# Definir le repertoire de travail ----\r\n\r\nsetwd(\"C-02-ManipulationDonnees\")\r\n\r\n# Importer les donnees ----\r\n\r\ncroissance <- read_csv(\"https://raw.githubusercontent.com/codons-blog/C-02-ManipulationDonnees/main/croissance.csv\")\r\n\r\n\r\n\r\n\r\nIl est toujours utile de visualiser vos données et leur structure :\r\n\r\n\r\n# Exploration rapide des donnees ----\r\n\r\nhead(croissance)  # affiche les premieres lignes\r\nstr(croissance)  # types des variables\r\nunique(croissance$Zone)  # affiche les valeurs distinctes de la variable Zone\r\ncroissance$Indiv  # affiche toutes les valeurs de la variable Indiv\r\nlength(unique(croissance$Indiv))  # affiche le nombre d'individus\r\n\r\n\r\n\r\n\r\nLorsque vous exécutez la commande head(croissance), vous pouvez remarquer dans la console la mention “A tibble”. Un tibble est un format particulier de tableau utilisé dans le Tidyverse. Il présente notamment l’avantage d’afficher les types de variables sous les noms de colonnes.\r\n\r\nRenommer des variables avec rename()\r\nCette fonction s’utilise de la façon suivante : rename(objet, nouveau_nom = ancien_nom).\r\n\r\n\r\n# Supprimer les majuscules dans les noms de colonnes\r\ncroissance <- rename(croissance,\r\n                      zone = Zone,\r\n                      indiv = Indiv)\r\n\r\n\r\n\r\n Avant d’aller plus loin, nous allons voir une fonctionnalité extrêmement pratique : le “pipe”. Un pipe permet d’enchaîner les opérations, et présente plusieurs avantages, notamment de rendre le code plus clair et lisible et de rendre possible l’auto-complétion (à l’aide de la touche Tab).\r\nLe pipe fait partie du package magrittr, inclus dans le Tidyverse.\r\nUn pipe se place à la fin d’un ligne sous la forme %>% :\r\n\r\nRaccourci clavier : Ctrl + Shift + M\r\n\r\n\r\ncroissance <- croissance %>% \r\n  rename(zone = Zone,\r\n         indiv = Indiv)\r\n\r\n\r\n\r\n\r\nSélectionner des colonnes avec select()\r\nCette fonction permet de sélectionner des colonnes, en précisant lesquelles conserver ou supprimer :\r\n\r\n\r\n# Conserver des colonnes\r\n\r\ncroissance_selection <- croissance %>% \r\n  select(indiv, `2007`:`2012`)\r\n\r\n# Supprimer une colonne\r\n\r\ncroissance_selection <- croissance %>% \r\n  select(-zone)\r\n\r\n\r\n\r\n\r\nLa fonction select() permet également de renommer des colonnes et d’en modifier l’ordre :\r\n\r\n\r\n# Renommer et modifier l'ordre de colonnes\r\n\r\ncroissance_selection <- croissance %>% \r\n  select(zone = Zone, indiv = Indiv, `2007`:`2012`)\r\n\r\n\r\n\r\n\r\nL’opérateur : permet de construire une séquence : dans le cas présent il permet de sélectionner toutes les colonnes entre 2007 et 2012.\r\nSi vous souhaitez renommer ou déplacer seulement quelques colonnes, la fonction everything() vous permet de sélectionner toutes les colonnes restantes :\r\n\r\n\r\ncroissance_selection <- croissance %>% \r\n  select(zone = Zone, indiv = Indiv, everything())\r\n\r\n\r\n\r\n\r\nFiltrer des données avec filter()\r\nCette fonction permet de sélectionner des lignes à l’aide d’opérateurs logiques :\r\nOpérateur\r\nExpression logique\r\n==\r\nstrictement égal à\r\n<=\r\ninférieur ou égal à\r\n<\r\ninférieur à\r\n>=\r\nsupérieur ou égal à\r\n>\r\nsupérieur à\r\n!=\r\ndifférent de\r\n%in%\r\nappartient à\r\n&\r\net\r\n|\r\nou\r\n!\r\npas\r\nVoyons comment utiliser ces opérateurs logiques :\r\n\r\n\r\n# individu n°603\r\n\r\ncroissance %>% filter(indiv == 603)\r\n\r\n# zones 2, 3 et 4\r\n\r\ncroissance %>% filter(zone <= 4)\r\ncroissance %>% filter(zone %in% c(2, 3, 4))\r\ncroissance %>% filter(zone %in% 2:4)\r\ncroissance %>% filter(!zone >= 5)\r\n\r\n# zones 2 et 7\r\n\r\ncroissance %>% filter(zone == 2 | zone == 7)\r\ncroissance %>% filter(zone %in% c(2, 7))\r\n\r\n# zone 2 + individus entre 300 et 400\r\n\r\ncroissance %>% filter(zone == 2 & indiv %in% 300:400)\r\ncroissance %>% filter(zone == 2 & between(indiv, 300, 400))\r\n\r\n\r\n\r\n\r\nIl existe différentes façons de construire une séquence :\r\n\r\n\r\nseq(from = 300, to = 400, by = 10)  # de 300 a 400 avec un increment de 10\r\nrep(x = c(300, 350), times = 2)  # 2 repetitions du vecteur \"300, 350\"\r\nrep(x = c(300, 350), each = 2)  # chaque element du vecteur \"300, 350\" est repete 2 fois\r\nrep(seq(from = 300, to = 400, by = 10), times = 4)  # combinaison des deux\r\n\r\n\r\n\r\n\r\nTrier des données avec arrange()\r\nLa fonction arrange() permet de trier des valeurs par ordre croissant ou décroissant :\r\n\r\n\r\n# Trier par ordre croissant sur l'annee 2007\r\n\r\ncroissance %>% arrange(`2007`)\r\n\r\n# Trier par ordre decroissant sur l'annee 2008\r\n\r\ncroissance %>% arrange(desc(`2008`))\r\n\r\n\r\n\r\n\r\nCréer de nouvelles colonnes avec mutate()\r\nLa fonction mutate() permet de créer un nouvelle colonne :\r\n\r\n\r\n# Calculer la croissance totale pour chaque individu entre 2007 et 2012\r\n\r\ncroissance_totale <- croissance %>% \r\n  mutate(croissance.totale = `2007` + `2008` + `2009` + `2010` + `2011` + `2012`)\r\n\r\n\r\n\r\n\r\nDéfinir des groupes avec group_by()\r\nCette fonction permet de créer une structure interne à vos données, par exemple des individus regroupés par zone. Les fonctions exécutées après l’appel à la fonction group_by() tiendront compte de cette structure interne. L’utilisation de la fonction group_by() associée à d’autres fonctions est très utile pour calculer des statistiques pour différents sites, traitements, espèces, …\r\n\r\n\r\n# Grouper les individus par zone\r\n\r\ncroissance_groupes <- croissance %>% \r\n  group_by(zone)\r\n\r\n\r\n\r\n\r\nComparez les deux objets croissance et croissance_groupes. La seule différence visible est la mention Groups quand vous affichez l’objet possédant une structure interne. Pour l’instant, les groupes créés par group_by() sont sous-jacents, et leur intérêt sera évident en appliquant d’autres fonctions à ces groupes.\r\n\r\nAgréger des lignes et calculer des statistiques avec summarise()\r\nCette fonction permet d’agréger des lignes en appliquant une fonction sur une ou plusieurs colonnes :\r\n\r\n\r\n# Croissance totale pour l'ensemble des individus pour l'annee 2007\r\n\r\nsynthese1 <- croissance %>% \r\n  summarise(croissance.totale.2007 = sum(`2007`))\r\n\r\n# Croissance totale pour l'ensemble des individus groupes par zone pour l'annee 2007\r\n\r\nsynthese2 <- croissance_groupes %>% \r\n  summarise(croissance.totale.2007 = sum(`2007`))\r\n\r\n\r\n\r\n\r\nLe premier objet, synthese1, correspond à la somme de toutes les valeurs de croissance pour tous les individus en 2007. Le second objet, synthese2, correspond à la somme des valeurs de croissance pour les individus regroupés par zone en 2007.\r\n\r\nLes données étant agrégées, le tableau de sortie sera plus court que les données d’origine.\r\nVous pouvez de cette façon calculer plusieurs paramètres :\r\n\r\n\r\nsynthese3 <- croissance_groupes %>% \r\n  summarise(croissance.totale.2007 = sum(`2007`),\r\n            croissance.moyenne.2007 = mean(`2007`),\r\n            croissance.ecart.type.2007 = sd(`2007`)) \r\n\r\n\r\n\r\n\r\nJoindre des données avec ..._join()\r\nIl peut arriver que des données concernant un même projet se trouvent dans plusieurs fichiers (par exemple un fichier avec des mesures sur différents sites, et un autre fichier avec des données climatiques pour ces différents sites).\r\n\r\nLes différentes fonctions ..._join() permettent de joindre plusieux jeux de données selon ce qu’on souhaite faire des données qui ne sont pas partagées. Les lignes d’un tableau seront associées à l’autre tableau selon les valeurs d’une ou de plusieurs colonnes partagées (les clés).\r\n\r\n\r\n\r\nFigure tirée de R for Data Science\r\n\r\nLe fichier traitements.csv contient des informations sur des traitements appliqués aux plantes : températe (T), fertilisation (F), température + fertilisation (TF), ou contrôle (C).\r\n\r\n\r\n# Importer le jeu de données (attention : utilisation de read_csv2)\r\n\r\ntraitements <- read_csv2(\"https://raw.githubusercontent.com/codons-blog/C-02-ManipulationDonnees/main/traitements.csv\")\r\n\r\n\r\n\r\n\r\nNous allons utiliser la fonction left_join() pour garder toutes les données présentes dans croissance et y associer les données présentes dans traitements :\r\n\r\n\r\n# Joindre deux jeux de données\r\n\r\nexpe <- croissance %>% \r\n  left_join(traitements,\r\n            by = c(\"zone\" = \"Zone\",\r\n                   \"indiv\" = \"Indiv\"))\r\n\r\n\r\n\r\n\r\nSi les noms des deux premières colonnes avaient été strictement identiques dans les deux tableaux, nous aurions pu nous passer de l’argument by().\r\n\r\nMettre en forme des données à l’aide de tidyr\r\nLes données que nous avons manipulées jusqu’à présent ne sont pas dans un format idéal (rappelez-vous la longueur du code pour calculer la croissance totale pour chaque individu).\r\nLes valeurs mesurées sont réparties dans différentes colonnes, une par année.\r\nNous pourrions mettre en forme ces donnes afin d’avoir une colonne “annee” et une colonne “croissance”.\r\nC’est ce qu’on appelle des tidy data, concept qui repose sur trois critères :\r\n1. Chaque variable est située dans sa propre colonne2. Chaque observation est située sur sa propre ligne3. Chaque valeur est située dans sa propre cellule\r\n\r\n\r\n\r\nFigure tirée de R for Data Science\r\n\r\nConsidérons les deux premières lignes de notre tableau croissance, voici à quoi ressemblerait un format tidy :\r\n\r\n\r\n\r\n\r\nCe format facilite les analyses en permettant des comparaisons entre groupes, traitements, espèces, années, …\r\nLe package tidyr permet de jongler entre ces deux formats grâce aux fonctions pivot_...().\r\n\r\n\r\n\r\n\r\nFormat long avec pivot_longer()\r\nLa fonction pivot_longer() permet de passer d’un format large à un format long. La syntaxe est un peu plus complexe que les fonctions que nous avons vues jusqu’à présent, car il nous préciser quelles colonnes vont être regroupées :\r\n\r\n\r\n\r\n\r\n\r\n# Format large -> format long\r\n\r\ncroissance_long <- croissance %>% \r\n  pivot_longer(cols = `2007`:`2012`,\r\n               names_to = \"annee\",\r\n               values_to = \"croissance\")\r\n\r\n\r\n\r\n\r\nFormat large avec pivot_wider()\r\nCette fonction permet d’effectuer l’opération inverse :\r\n\r\n\r\n\r\n\r\n\r\n# Format long -> format large\r\n\r\ncroissance_large <- croissance_long %>% \r\n  pivot_wider(id_cols = zone:indiv,\r\n              names_from = annee,\r\n              values_from = croissance)\r\n\r\n\r\n\r\n\r\nDans les arguments names_from et values_from nous n’utilisons pas de guillemets car ces colonnes existent, contraitement aux arguments names_to et values_to de la fonction pivot_longer() qui permettent de créer des colonnes inexistantes.\r\n\r\nRésumé\r\nNous avons vu les principales fonctions des packages dplyr et tidyr une par une. Nous allons maintenant enchaîner les différentes opérations depuis le début à l’aide d’un pipe et visualiser l’effet des différents traitements sur la croissance des tiges d’Empetrum :\r\n\r\n\r\n# Importer les deux fichiers\r\n\r\ncroissance <- read_csv(\"https://raw.githubusercontent.com/codons-blog/C-02-ManipulationDonnees/main/croissance.csv\")\r\ntraitements <- read_csv2(\"https://raw.githubusercontent.com/codons-blog/C-02-ManipulationDonnees/main/traitements.csv\")\r\n\r\n# Mettre en forme et joindre les deux fichiers\r\n\r\nexpe <- croissance %>% \r\n  pivot_longer(cols = `2007`:`2012`,\r\n               names_to = \"annee\",\r\n               values_to = \"croissance\") %>% \r\n  left_join(traitements) %>% \r\n  rename(zone = Zone,\r\n         indiv = Indiv,\r\n         traitement = Traitement) %>% \r\n  mutate(zone = as.factor(zone),\r\n         indiv = as.factor(indiv),\r\n         annee = as.numeric(annee),\r\n         traitement = as.factor(traitement))\r\n\r\n# Boxplot de l'effet des traitements sur la croissance\r\n\r\nboxplot(croissance ~ traitement, \r\n        data = expe,\r\n        main = \"Effet de la température (T) et de la fertilisation (F) sur la croissance d'Empetrum\",\r\n        xlab = \"Traitement\",\r\n        ylab = \"Croissance des tiges (cm)\")\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nBilan du tutoriel :\r\nVous savez utiliser les fonctions de dplyr pour manipuler vos données\r\nVous savez mettre en forme des données qui respectent les critères des tidy data avec tidyr\r\n\r\nDéfi\r\nPour ce défi, nous allons essayer de répondre à la question suivante : quelle est l’effet de différentes épices sur la taille des flammes de trois espèces de dragons ? \r\n\r\nCommençons par importer les données :\r\n\r\n\r\ndragons <- read.csv(\"https://raw.githubusercontent.com/codons-blog/C-02-ManipulationDonnees/main/dragons.csv\")\r\n\r\n\r\n\r\n\r\nVoici les objectifs de ce défi :\r\nmettre en forme les données (format tidy)\r\ncréer un boxplot pour chaque espèce montrant l’effet des épices sur la taille des flammes\r\n\r\nMalheureusement, vous apprenez que votre assistant a été peu scrupuleux lors de la collecte des données, et il vous faut corriger les erreurs suivantes :\r\nLa quatrième épice n’était pas du paprika, mais du curcuma\r\nLors des mesures avec le tabasco, l’appareil était mal calibré, mais seulement pour les Magyar à pointes : la taille des flammes a été sur-estimée de 30 cm\r\nLes tailles sont données en centimètres, alors qu’elles devraient être en mètres.\r\n\r\nA votre tour de jouer!\r\n\r\nSi vous êtes coincé, vous pouvez cliquer ci-dessous pour afficher quelques astuces :\r\n\r\n\r\nShow code\r\n\r\n# 1. Pour renommer la colonne \"paprika\", utilisez la fonction rename()\r\n\r\n# 2. Il existe plusieurs facons de corriger des valeurs :\r\n\r\nvaleurs_corrigees <- dragons$tabasco[dragons$espece == \"magyar_a_pointe\"] - 30\r\ndragons$tabasco[dragons$espece == \"magyar_a_pointe\"] <- valeurs_corrigees\r\n\r\ndragons <- dragons %>% \r\n  mutate(tabasco = ifelse(espece == \"magyar_a_pointe\", tabasco - 30, tabasco))\r\n\r\ndragons <- dragons %>% \r\n  mutate(tabasco = case_when(espece == \"magyar_a_pointe\" ~ tabasco - 30,\r\n                             TRUE ~ tabasco))\r\n\r\n# 3. La fonction mutate() vous permettra de convertir les centimètres en mètres\r\n\r\n\r\n\r\n\r\nCliquez ci-dessous pour voir la solution\r\n\r\n\r\nShow code\r\n\r\n# Importer les donnees\r\n\r\ndragons <- read_csv(\"https://raw.githubusercontent.com/codons-blog/C-02-ManipulationDonnees/main/dragons.csv\")\r\n\r\n# Nettoyer et corriger les donnees\r\n\r\ndragons_tidy <- dragons %>% \r\n  rename(curcuma = paprika) %>% \r\n  pivot_longer(cols = tabasco:curcuma,\r\n               names_to = \"epice\",\r\n               values_to = \"flamme_cm\") %>% \r\n  mutate(flamme_cm = case_when(espece == \"magyar_a_pointes\" & epice == \"tabasco\" ~ flamme_cm - 30,\r\n                               TRUE ~ flamme_cm)) %>% \r\n  mutate(flamme_m = flamme_cm / 100)\r\n\r\nmagyar_a_pointes <- dragons_tidy %>% filter(espece == \"magyar_a_pointes\")\r\nsuedois_a_museau_court <- dragons_tidy %>% filter(espece == \"suedois_a_museau_court\")\r\nvert_gallois <- dragons_tidy %>% filter(espece == \"vert_gallois\")\r\n\r\n# Boxplots\r\n\r\npar(mfrow = c(1, 3))\r\n\r\nboxplot(flamme_m ~ epice,\r\n        data = magyar_a_pointes,\r\n        xlab = \"Epice\",\r\n        ylab = \"Longueur flamme (m)\",\r\n        main = \"Magyar à pointes\")\r\n\r\nboxplot(flamme_m ~ epice,\r\n        data = suedois_a_museau_court,\r\n        xlab = \"Epice\",\r\n        ylab = \"Longueur flamme (m)\",\r\n        main = \"Suédois à museau court\")\r\n\r\nboxplot(flamme_m ~ epice,\r\n        data = vert_gallois,\r\n        xlab = \"Epice\",\r\n        ylab = \"Longueur flamme (m)\",\r\n        main = \"Vert gallois\")\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/manipuler-donnees-tidyverse/img/data_cowboy.png",
    "last_modified": "2022-06-09T15:51:28+02:00",
    "input_file": {}
  },
  {
    "path": "posts/premiers-pas-avec-r/",
    "title": "Premiers pas avec R",
    "description": "Débuter avec R et RStudio.",
    "author": [
      {
        "name": "Gergana Daskalova",
        "url": "https://ourcodingclub.github.io/tutorials/intro-to-r/"
      },
      {
        "name": "Jonathan Kitt (adaptation)",
        "url": {}
      }
    ],
    "date": "2022-05-02",
    "categories": [
      "R",
      "RStudio",
      "Introduction"
    ],
    "contents": "\r\n\r\nContents\r\nIntroduction\r\nTélécharger R et RStudio\r\nImporter et vérifier les données\r\nCompter le nombre d’espèces menacées\r\nCréer un vecteur et le représenter\r\nCréer un dataframe et le représenter\r\nDéfi\r\nGlossaire\r\n\r\n\r\n\r\n\r\nCe tutoriel est adapté de Getting started with R and RStudio du site Our Coding Club.\r\n\r\n\r\n\r\nDessin de Allison Horst\r\nIntroduction\r\n\r\nLes objectifs de ce tutoriel sont les suivants :\r\nComprendre ce qu’est R (et RStudio)\r\nPrendre la bonne habitude de travailler avec des scripts\r\nApprendre à importer des données dans R\r\nApprendre à manipuler des objets (vecteurs et data frames)\r\nCréer un graphique basique\r\nVoici les étapes que nous allons suivre pour y parvenir :\r\nTélécharger R et RStudio\r\nImporter et vérifier les données\r\nCompter le nombre d’espèces menacées\r\nCréer un vecteur et le représenter\r\nCréer un data frame et le représenter\r\nDéfi\r\nGlossaire\r\nQu’est-ce que R?\r\nR est un langage de programmation statistique qui a rapidement gagné en popularité dans de nombreux domaines scientifiques. Il a été développé par Ross Ihaka et Robert Gentleman comme implémentation libre du langage de programmation S.\r\n\r\nR désigne également le logiciel qui utilise ce langage pour des calculs statistiques (et tout un tas d’autres applications !). Il dispose d’une communauté en ligne très active ainsi que d’extensions pour presque tous les domaines et applications possibles et imaginables.\r\n\r\nContrairement à d’autres logiciels de statistiques comme Minitab ou SPSS, R peut être exécuté entièrement en ligne de commande et ne nécessite pas d’interface graphique, ce qui lui confère une grande flexibilité.\r\n\r\nVoici quelques avantages de R :\r\nC’est un outil libre et open source (tout le monde peut utiliser le code et voir comment il fonctionne)\r\nC’est un langage de programmation plutôt qu’une interface graphique, ce qui permet à l’utilisateur de sauvegarder facilement des scripts sous forme de texte pour les ré-utiliser ou les partager\r\nBeaucoup de personnes l’utilisent dans beaucoup de domaines différents - il est rare d’être confronté à un problème qui n’a jamais été résolu !\r\n\r\nTélécharger R et RStudio\r\nLa plupart des utilisateurs interagissent avec R à l’aide d’une interface graphique, dont la plus connue est RStudio. RStudio permet d’avoir accès dans une seule fenêtre à vos scripts, à vos données, à vos graphiques, à vos résultats, ainsi qu’à de l’aide.\r\n\r\nTéléchargez R sur le site du CRAN (The Comprehensive R Archive Network)\r\nTéléchargez RStudio (“free open source desktop version”)\r\nSur Mac, vous aurez également besoin de XQuartz\r\n\r\nOuvrez RStudio, puis cliquez sur “File / New File / R script”\r\n\r\n\r\n\r\nVous verrez une fenêtre comme celle ci-dessus, avec quatre panneaux :\r\n1) La console : vous pouvez y taper du code et l’exécuter avec Entrée.\r\n\r\nEssayez de taper et d’exécuter 2+2\r\n2) Le script : vous pouvez - et c’est préférable - y taper du code. Pour l’exécuter, placez-vous à la fin de la ligne et utilisez la combinaison de touches Ctrl + R (Windows) ou Cmd + Entrée (Mac).\r\n\r\nSur les ordinateurs avec une version récente de Windows, Ctrl + Entrée\r\n3) L’environnement : aperçu de votre espace de travail (données importées, objets créés, fonctions définies, …).\r\n4) Fichiers / Graphiques / Packages / Aide : permet de naviguer dans vos dossiers, de visualiser vos graphiques, de voir quels packages sont installés et chargés, et d’obtenir de l’aide.\r\nA propos des scripts :  gardez bien à l’esprit que le code tapé directement dans la console ne sera pas sauvegardé par R : il disparaît une fois exécuté (vous pouvez toutefois accéder aux dernières commandes à l’aide de la touche Flèche du haut de votre clavier). L’utilisation d’un script pour taper votre code vous permet d’en garder une trace. C’est un peu comme quand vous rédigez un document dans Word : vous pouvez sauvegarder votre progression pour reprendre là où vous en étiez, ou faire des modifications. Lorsque vous tapez du code dans un script, pensez à le sauvegarder régulièrement (Ctrl + S).\r\nIl est fortement recommandé d’ajouter à votre code des commentaires décrivant les étapes. Pour cela, insérez un hashtag (#) devant une ligne de votre script (ou Ctrl + Shift + C). Toutes les lignes qui commencent par un # seront considérées par R comme du texte et non du code, et ne seront pas exécutées. Ces commentaires apporteront des informations précieuses pour toute personne qui lira votre script (y compris vous-même quand vous reviendrez dessus dans un certain temps !). Comme tout document écrit, les scripts sont plus facilement lisibles quand ils sont bien structurés et clairs.\r\nA propos de l’espace de travail :  votre espace de travail contient tout ce que vous utilisez lors d’une session R. En quittant R, vous aurez le choix de sauvegarder ou non cet espace de travail. Il est préférable de ne pas le faire et de démarrer chaque session avec en espace de travail vide. \r\nTéléchargez les données\r\nLa meilleure façon d’apprendre un nouveau langage est de le pratiquer. Nous allons analyser une liste d’espèces d’oiseaux menacées en Auvergne (données de 2015 obtenues sur le site de la DREAL). Ces données se trouvent dans un fichier appelé oiseaux.csv.\r\n1) Créez un nouveau dossier sur votre ordinateur : vous allez y télécharger les données, et vous pourrez y sauvegarder votre script et vos graphiques. Choisissez un nom explicite, par exemple codons_01_intro_r\r\n\r\nEvitez les espaces vides dans vos noms de dossiers !\r\n2) Cliquez sur ce lien pour télécharger le fichier oiseaux.csv\r\n3) Cliquez sur “Code” puis “Download ZIP” (voir ci-dessous)\r\n\r\n\r\n\r\n4) Choisissez comme emplacement de sauvegarde le dossier que vous venez de créer\r\n5) Dézippez le dossier\r\nCommencez à écrire votre script\r\nPour l’instant, vous pouvez noter la date et l’objectif du tutoriel - compter le nombre d’espèces d’oiseaux menacées d’extinction en Auvergne. Vous pouvez copier l’exemple ci-dessous pour le coller et l’éditer dans votre propre script :\r\n\r\n\r\n# Ateliers codon(s)!\r\n# 01 - Premiers pas avec R\r\n# Lundi 09/05/2022\r\n\r\n\r\n\r\nLes lignes suivantes dans votre script servent généralement à charger les packages dont vous aurez besoin pour votre analyse. Un package contient des commandes qui peuvent être chargées dans R pour apporter des fonctionnalités supplémentaires (il existe par exemple des packages pour formater des données ou pour créer des cartes).\r\nUn package doit tout d’abord être téléchargé et installé sur votre ordinateur à l’aide de la commande install.packages(\"nom-du-package\") avant d’être chargé pour être utilisé à l’aide de la commande library(nom-du-package). Un package n’a besoin d’être installé qu’une seule fois, vous pouvez donc le faire directement dans la console plutôt que de sauvegarder la ligne de code dans votre script et d’ainsi le ré-installer à chaque fois que vous exécutez votre script. Nous allons utiliser le package dplyr qui fournit des fonctionnalités supplémentaires pour la manipulation et le formatage de données.\r\n\r\nNotez bien la présence de guillemets autour du nom du package dans l’appel à la fonction install.packages(), et leur absence dans l’appel à la fonction library()\r\n\r\n\r\ninstall.packages(\"dplyr\")\r\nlibrary(dplyr)\r\n\r\n\r\n\r\nNous allons maintenant définir notre répertoire de travail - le dossier dans lequel R cherchera les données à importer et sauvegardera les graphiques. C’est dans notre cas le dossier dans lequel nous avons téléchargé les données.\r\nQuand vous aurez à travailler sur des projets plus importants, vous pourrez tout à fait créer un dossier racine (par ex. “nom_du_projet/”), le définir comme répertoire de travail, et créer des sous-dossiers pour organiser les fichiers (par ex. “nom_du_projet/donnees_brutes/”, “nom_du_projet/figures/”, …).\r\nPour afficher le réperoire de travail, utilisez la commande getwd() (pour get working directory). La commande setwd(\"nom-du-repertoire-de-travail\") (set working directory) permet de définir un nouveau répertoire de travail.\r\n\r\nFaites attention au sens des slashes dans vos chemins de dossiers !\r\n\r\n\r\nsetwd(\"C:/User/Codons-01-PremiersPasAvecR\")\r\n# Remplacez le chemin ci-dessus par le votre\r\n\r\n\r\n\r\n\r\nL’auto-complétion est votre alliée ! Tapez quelques lettres puis sur la touche Tab et R complètera pour vous.\r\nImporter et vérifier les données\r\nPour importer les données dans RStudio, deux options s’offrent à vous :\r\nCliquer sur le bouton Import Dataset\r\n\r\n\r\n\r\nIndiquez quel fichier vous souhaitez importer, et RStudio vous proposera un aperçu de vos données. Assurez-vous qu’à côté de Heading vous avez sélectionné Yes (ceci indique à R qu’il doit considérer la première ligne de vos données comme des noms de colonnes). Cliquez enfin sur Import.\r\n\r\n\r\n\r\nDans la console vous verrez le code utilisé pour importer vos données, y compris le chemin vers votre fichier - il est utile de copier cette ligne de code et de la coller dans votre script, pour que vous sachiez d’où vient votre jeu de données.\r\nVous remarquerez que le chemin vers votre fichier débute par C:/. Il s’agit du chemin absolu vers le fichier à importer, qui ne tient pas compte du fait que vous avez défini un répertoire de travail. Vous pouvez également utiliser le chemin relatif qui indique l’emplacement du fichier à partir de votre répertoire de travail (voir ci-dessous)\r\nUtiliser la commande read.csv() : R fonctionne mieux avec des fichiers .csv (valeurs séparées par des virgules). Si vous travaillez dans Excel, cliquez sur Enregistrer sous et choisissez csv comme extension de fichier.\r\n\r\nDans Excel, évitez les espaces dans vos noms de colonnes (ex : nom_latin plutôt que nom latin)\r\nCertains ordinateurs utilisent le point-virgule ; comme séparateur dans les fichiers .csv. Vous pouvez dans ce cas utiliser la fonction read.csv2(), ou préciser dans la fonction read.csv() l’argument sep = \";\".\r\n\r\n\r\noiseaux <- read.csv(\"Codons-01-PremiersPasAvecR-main/oiseaux.csv\")\r\n# modifiez le chemin vers le fichier si nécessaire\r\n\r\n\r\n\r\nA propos des objets : R est langage orienté objet - cela signifie que tout ce que vous importez et créez est stocké dans des objets que vous allez nommer. Ici, nous avons assigné le fichier oiseaux.csv à l’objet oiseaux à l’aide de la flèche <-. Nous aurions tout à fait pu l’appeler mesdonnees ou oiseaux_liste_rouge_auvergne, mais il est préférable de choisir un nom unique, informatif et court. Dans le panneau Environment de RStudio vous pouvez voir les noms de tous les objets actuellement chargés dans R. Assurez-vous que vous voyez bien l’objet oiseaux.\r\nQuand vous importez vos données dans R, il est très probable qu’elles deviennent un objet qu’on appelle un data frame : un tableau contenant des lignes (observations) et des colonnes (variables).\r\nUne des premières choses à faire est de vous assurer que vos données ont été importées sans erreur. Il est recommandé de toujours exécuter ce code dans la console et de vérifier le résultat - voyez-vous des erreurs, est-ce que les nombres/noms ont du sens ? Si vous passiez directement à l’analyse, vous risqueriez de vous rendre compte plus tard que R n’a pas importé vos données correctement et vous devriez recommencer, ou pire, vous pourriez analyser de mauvaises données sans vous en rendre compte. Pour visualiser davantage que les quelques premières lignes, vous pouvez également cliquer sur l’objet dans le panneau Environment, ce qui affichera un tableau dans un nouvel onglet à côté de votre script. Des fichiers peuvent être trop larges pour êtres affichés entirement, gardez donc à l’esprit qu’il peut y avoir des lignes ou des colonnes manquantes.\r\n\r\n\r\nhead(oiseaux)  # affiche les premières lignes\r\ntail(oiseaux)  # affiche les dernières lignes\r\nstr(oiseaux)  # affiche le type de variables\r\n\r\n\r\n\r\nLa commande str(nom.objet) affiche la structure de vos données. Très souvent, les analyses ne se déroulent pas comme prévu car R s’est trompé de type de variable. Imaginez que vos données comportent quatre groupes d’étude appelés “1, 2, 3, 4”. Vous savez pertinnement qu’il s’agit d’une variable catégorique (un facteur), mais R peut considérer qu’il s’agit d’une variable numérique.\r\n\r\nPensez toujours à vérifier la structure de vos données !\r\nLa fonction str(oiseaux) nous indique que la variable categorie est une chaîne de caractères (chr). Nous préférerions que R considère cette variable comme étant catégorique - un facteur. Nous allons le préciser en accédant à la colonne concernée à l’aide du signe dollar $ :\r\n\r\n\r\nhead(oiseaux$categorie)  # premiers éléments de la variable\r\nclass(oiseaux$categorie)  # type de variable\r\noiseaux$categorie <- as.factor(oiseaux$categorie)\r\n\r\n\r\n\r\nLa dernière ligne du code ci-dessus permet de transformer la variable categorie en un facteur. La fonction as.factor(oiseaux$categorie) toute seule serait exécutée, mais ne modifierait pas les données stockées dans l’objet oiseaux. Il faut pour cela ré-assigner cette variable transformée en facteur à la variable d’origine. Pour vous assurer que l’opération a bien fonctionné, vous pouvez exécuter à nouveau la fonction class(oiseaux$categorie).\r\nLes fonctions suivantes permettent d’explorer autrement vos données :\r\n\r\n\r\ndim(oiseaux)  # dimensions de l'objet\r\nsummary(oiseaux)  # synthèse de l'objet\r\nsummary(oiseaux$categorie)  # synthèse de la variable\r\n\r\n\r\n\r\nCompter le nombre d’espèces menacées\r\nNotre objet oiseaux dresse une liste des espèces d’oiseaux menacées d’extinction en Auvergne, avec différents niveaux de préoccupation.\r\nNous allons compter le nombre d’espèces pour chaque niveau de préoccupation et créer une visualisation de ce comptage.\r\nCommençons par séparer oiseaux en plusieurs objets, un pour chaque niveau de menace, à l’aide de la fonction filter() du package dplyr.\r\n\r\n\r\nen_danger_critique <- filter(oiseaux, categorie == \"En danger critique\")\r\n# Le 1er argument de la fonction est le data frame, \r\n# Le 2e argument est la condition à appliquer au filtre\r\n\r\n\r\n\r\n\r\nL’opérateur == permet de sélectionner les valeurs “strictement égales à”\r\nR est sensible à la casse : filter(oiseaux, categorie == \"en danger critique\") ne fonctionnera pas !\r\nProcédons de la même façon pour chaque catégorie. Si vous avez un doute sur le nom ou l’orthographe d’une des catégories, pensez à la fonction summary(oiseaux$categorie).\r\nUne fois que vous avez créé tous les objets, vous allez pouvoir compter le nombre d’espèces pour chaque catégorie. Nous allons pour cela imbriquer deux fonctions : unique() (pour identifier chaque espèce) et length() (pour les compter).\r\n\r\nVous pouvez essayer ces deux fonctions séparément dans la console\r\n\r\n\r\na <- length(unique(en_danger_critique$nom_francais))\r\n# choisissez des noms pratiques pour vos objets\r\n# \"a\" n'est peut-être pas le plus explicite ...\r\n\r\n\r\n\r\nProcédez de la même façon pour toutes les catégories. Cette manière de procéder peut vous sembler rébarbative … Nous verrons dans un prochain tutoriel comment procéder de manière plus efficace !\r\nTapez dans la console le nom d’un des objets que vous venez de créer. Que vous retourne-t-elle ?\r\nCréer un vecteur et le représenter\r\nNous allons maintenant combiner tous ces objets dans un vecteur - un objet à une dimension (à la différence d’un data frame qui en possède deux).\r\nNous utilisons pour cela la fonction c() (pour concaténer), ainsi que la fonction names() pour ajouter des étiquettes aux valeurs.\r\n\r\n\r\ncomptage_especes <- c(a,b, c, d, e)\r\nnames(comptage_especes) <- c(\"En danger critique\",\r\n                             \"En danger\",\r\n                             \"Vulnerable\",\r\n                             \"Quasi-menacee\",\r\n                             \"Preoccupation mineure\")\r\n\r\n\r\n\r\n\r\nAttention à garder le même ordre !\r\nNotes :\r\n- Les espaces avant et après la flèche <- et après la virgule , facilitent la lecture du code\r\n- Faites attention à vérifier que les valeurs du vecteur correspondent bien aux étiquettes - vous ne voudriez pas inverser les espèces “En danger critique” avec les espèces “Quasi-menacées”! L’utilisation d’un script permet de revenir sur le code et de vérifier qu’on ne s’est pas trompé. Une bonne pratique serait de nommer les objets de façon plus explicite, comme nb_en_danger_critique, nb_en_danger, …\r\n- Si vous cliquez à l’aide de la souris après une parenthèse, RStudio surlignera la parenthèse lui correspondant. Les parenthèses manquantes, en particulier quand vous utilisez des fonctions imbriquées comme vous l’avez fait avec length(unique()) sont une des sources de frustration et d’erreur les plus courantes quand vous commencez à coder !\r\nNous pouvons maintenant visualiser le nombre d’espèces par catégorie à l’aide de la fonction barplot(). Les graphiques s’affichent dans le panneau inférieur droit de RStudio.\r\n\r\n\r\nbarplot(comptage_especes)\r\n\r\n\r\n\r\nEt voilà votre premier graphique avec R ! Mais il y a des choses à modifier : il manque des titres aux axes, toutes les étiquettes ne sont pas visibles, et la valeur pour les espèces dans la catégorie “Préoccupation mineure” (n = 68) dépasse la plus grande valeur affichée sur l’axe Y.\r\nPour savoir comment apporter ces modifications à votre graphique, utilisez la fonction help(barplot) ou ?barplot pour afficher l’aide de la fonction. Survolez le document qui s’affiche et essayez de trouver des solutions.\r\n\r\n\r\nhelp(barplot)  # aide de la fonction barplot\r\nhelp(par)  # aide pour les graphiques\r\n\r\n\r\n\r\nNous aimerions également sauvegarder notre graphique. Là encore, vous avez deux options : - Cliquer sur Export dans le panneau des graphiques : choisissez où sauvegarder le graphique (par défaut dans votre répertoire de travail) et modifiez le nom du fichier pour qu’il soit plus explicite que Rplot01.png. Vous pouvez aussi ajuster les dimensions de la figure.\r\n\r\n\r\n\r\nUtiliser les fonctions png() et dev.off() qui servent respectivement à ouvrir et fermer l’outil graphique :\r\n\r\n\r\npng(\"barplot.png\",\r\n    width = 1600, height = 600)\r\n\r\nbarplot(comptage_especes,\r\n        xlab = \"Niveau de menace\", ylab = \"Nombre d'espèces\",\r\n        ylim = c(0, 70),\r\n        cex.names = 1.5, cex.axis = 1.5, cex.lab = 1.5)\r\n\r\ndev.off()\r\n\r\n\r\n\r\n\r\nL’argument cex permet d’augmenter (> 1) ou de diminuer (< 1) la taille du texte\r\n\r\n\r\n\r\nCréer un dataframe et le représenter\r\nNous avons travaillé jusqu’ici avec des vecteurs, un type d’objet bien adapté quand on manipule une seule série de valeurs à la fois. Dans la pratique, nous manipulons souvent plusieurs variables et plusieurs types de données en même temps - par exemple des valeurs continues et des valeurs catégoriques. Les data frames sont alors mieux adaptés : il s’agit de tableaux de valeurs ayant une structure en deux dimensions, des lignes et des colonnes, chaque colonne pouvant contenir un type différent de données.\r\nNous pourrions par exemple avoir un tableau de données dont une colonne appelée “Envergure” contient des mesures d’envergures chez différentes espèces d’oiseaux, et une deuxième colonne appelée “Espèce” contient les noms des espèces dont on a mesuré l’envergure.\r\nLa matrice est un autre format possible de données : elle peut également contenir plusieurs lignes, mais toutes les variables d’une matrice doivent être du même type et contenir le même nombre d’éléments.\r\nConseil de bonne pratique : conservez toujours une copie de vos données brutes ! Votre script R vous permet de manipuler et modifier ces données sans toucher aux données brutes. Si vous utilisez des logiciels de retouche photo, c’est un peu la même chose que d’ajouter des couches apportant des modifications à votre cliché sans modifier la photo d’origine. Ceci dit, si vos données brutes nécessitent un long morceau de code pour être analysables, vous pouvez sauvegarder une version nettoyée de vos données brutes pour ne pas avoir à refaire toutes les étapes de nettoyage des données.\r\nNous allons utiliser deux nouvelles fonctions : data.frame() pour créer notre data frame et write.csv() pour le sauvegarder. Nous allons créer les objets “categories” et “comptage”, transformer l’objet “categories” en facteur, puis rassembler ces deux objets dans un data frame.\r\n\r\n\r\n# Creer un objet \"categories\"\r\ncategories <- c(\"En danger critique\",\r\n                \"En danger\",\r\n                \"Vulnerable\",\r\n                \"Quasi-menacee\",\r\n                \"Preoccupation mineure\")\r\n\r\n# Transformer cet objet en facteur\r\ncategories_f <- factor(categories)\r\n\r\n# Creer un objet \"comptage\"\r\ncomptage <- c(a, b, c, d, e)\r\n\r\n# Creer un data frame avec ces deux vecteurs\r\nespeces_menacees <- data.frame(categories_f, comptage)\r\n\r\n# Sauvegarder le data frame\r\nwrite.csv(especes_menacees, file = \"especes_menacees.csv\")\r\n\r\n\r\n\r\nPour créer un barplot à partir de ce data frame, vous devrez modifier le code utilisé précédemment - il faut en effet préciser quelle variable du data frame vous souhaitez représenter.\r\n\r\n\r\npng(\"barplot2.png\",\r\n    width = 1600, height = 600)\r\n\r\nbarplot(especes_menacees$comptage,\r\n        names.arg = c(\"En danger critique\",\r\n                      \"En danger\",\r\n                      \"Vulnerable\",\r\n                      \"Quasi-menacee\",\r\n                      \"Preoccupation mineure\"),\r\n        xlab = \"Niveau   de menace\", ylab = \"Nombre d'especes\",\r\n        ylim = c(0, 70),\r\n        cex.names = 1.5, cex.axis = 1.5, cex.lab = 1.5)\r\n\r\n\r\n\r\n\r\nIl existe une manière plus simple de préciser les étiquettes …\r\nBilan du tutoriel :\r\nVous vous êtes familiarisé avec l’interface RStudio\r\nVous savez comment créer et annoter un fichier de script\r\nVous pouvez importer vos propres données dans RStudio\r\nVous savez comment vérifier et explorer vos données\r\nVous pouvez générer des graphiques basiques et les exporter\r\nDéfi\r\nSi c’est votre premier contact avec R, ne vous inquiétez pas si vous ne comprenez pas tout, tout de suite. Revenez à tête reposée sur les parties que vous avez trouvées plus difficiles.\r\nVoici un petit défi pour mettre en pratique ce que vous avez vu dans ce tutoriel.\r\nVous verrez ci-dessous des données (fictives) de mesures d’envergure (en cm) pour quatre espèces différentes d’oiseaux. Essayez de créer un barplot de l’envergure moyenne pour chacune des espèces et sauvegardez-le sur votre ordinateur.\r\n\r\nIl vous faudra trouver une fonction permettant de calculer une moyenne\r\nespece\r\nenvergure (cm)\r\nAigle\r\n195\r\nChouette\r\n85\r\nColibri\r\n8\r\nMoineau\r\n24\r\nAigle\r\n201\r\nChouette\r\n102\r\nColibri\r\n9\r\nMoineau\r\n21\r\nAigle\r\n185\r\nChouette\r\n91\r\nColibri\r\n9\r\nMoineau\r\n22\r\nSolution\r\nNe regardez pas avant d’avoir essayé ! Il n’existe pas une seule solution possible, plusieurs façons de procéder amèneront au même résultat. Les noms des objets et l’apparence du graphique seront sans doute différents, et cela ne pose aucun problème - du moment que les valeurs elles-mêmes sont correctes.\r\n\r\n\r\nShow code\r\n\r\n# Extraire les envergures pour chaque espece\r\nenv_aigle <- c(195, 201, 185)\r\nenv_chouette <- c(85, 102, 91)\r\nenv_colibri <- c(8, 9, 9)\r\nenv_moineau <- c(24, 21, 22)\r\n\r\n# Calculer l'envergure moyenne\r\nenv_moy_aigle <- mean(env_aigle)\r\nenv_moy_chouette <- mean(env_chouette)\r\nenv_moy_colibri <- mean(env_colibri)\r\nenv_moy_moineau <- mean(env_moineau)\r\n\r\n# Rassembler ces valeurs moyennes dans un vecteur\r\nenv_moyenne <- c(env_moy_aigle, env_moy_chouette, env_moy_colibri, env_moy_moineau)\r\n\r\n# Creer un vecteur avec les noms des especes (attention à l'ordre !)\r\nespeces <- c(\"Aigle\", \"Chouette\", \"Colibri\", \"Moineau\")\r\n\r\n# Transformer ce vecteur en un facteur\r\nespeces_f <- as.factor(especes)\r\nclass(especes_f)\r\n\r\n# Combiner les deux vecteurs dans un data frame\r\nenvergure <- data.frame(especes_f, env_moyenne)\r\n\r\n# Sauvegarder le barplot dans un fichier\r\npng(\"barplot_envergure.png\",\r\n    width = 1600, height = 600)\r\n\r\nbarplot(envergure$env_moyenne,\r\n        names.arg = envergure$especes_f,\r\n        xlab = \"Espèces\", ylab = \"Envergure moyenne\",\r\n        ylim = c(0, 200),\r\n        cex.names = 1.5, cex.axis = 1.5, cex.lab = 1.5,\r\n        col = \"gold\")  # modifier la couleur des barres\r\n\r\ndev.off()\r\n\r\n\r\n\r\nGlossaire\r\n Voici quelques termes importants vus dans ce tutoriel :\r\nargument : élément d’une fonction, essentiel ou optionnel, qui précise ou modifie la façon dont la fonction est exécutée. Par exemple, il peut s’agir du chemin vers un fichier qui sera importé, ou de l’emplacement où sera sauvegardé un fichier : file = \"chemin-vers-le-fichier. Il peut aussi modifier les couleurs d’un graphique : col = \"blue\". Vous pouvez trouver une liste des arguments d’une fonction à l’aide de la commande ?nom-de-la-fonction.\r\nclasse : le type de données contenu dans une variable : habituellement des charactères (texte/mots), des nombres entiers ou relatifs, ou des facteurs (des valeurs de groupement, utiles quand vos données contiennent de multiples observations issues de différents sites ou traitements).\r\ncommande : un morceau de code qui exécute une action, contient généralement une ou plusieurs fonctions. Vous pouvez exécuter une commande en cliquant sur “Run” ou grâce aux raccourcis clavier comme Cmd + Entrée, Ctrl + Entrée ou Ctrl + R.\r\ncommentaire : un morceau de texte dans un script qui débute par un hashtag # et qui n’est pas lu comme une commande. Les commentaires rendent le code plus facilement lisible pour d’autres personnes : utilisez-les pour créer des sections dans votre script et pour annoter chaque étape de votre analyse.\r\nconsole : la fenêtre dans laquelle vous pouvez taper du code directement en ligne de commande (2+2 puis Entrée retournera 4), et où les résultats des commandes seront affichés.\r\ndata frame : un type d’objet R composé de nombreuses lignes et colonnes (pensez à une feuille Excel). Généralement les colonnes contiennent différentes variables (par exemple âge, couleur, poids, envergure), et les lignes les observations de ces variables (par exemple oiseau1, oiseau2, oiseau3).\r\nespace de travail : c’est votre environnement de travail virtuel, il contient toutes les fonctions des packages que vous avez chargés, les objets que vous avez créés, et ainsi de suite. Il est préférable de démarrer une session de travail avec un espace de travail vide.\r\nfichier csv : un type de fichier couramment utilisé pour importer des données dans R, où les valeurs des différentes variables sont compressées (une chaîne, ou une ligne de valeurs par ligne) et séparées seulement par des virgules (indiquant les colonnes). R peut aussi lire des fichiers Excel (.xlsx), mais cela n’est pas recommandé car il est difficile d’éviter les erreurs de formatage.\r\nfonction : du code qui exécute une action, c’est-à-dire tout ce que vous faites dans R. Une fonction prend une entrée, la modifie d’une façon ou d’une autre, et retourne une sortie (un objet, un résultat de test, un fichier, un graphique). Il existe des fonctions pour importer, convertir et manipuler des données, pour effectuer des calculs spécifiques (essayez de deviner ce que retourneraient les fonctions min(10, 15, 5) et max(10, 15, 5)), générer des graphiques, et bien davantage.\r\nobjet : les briques de construction de R. Si R était un langage parlé, les fonctions seraient les verbes (actions) et les objets les noms (les sujets ou les objets de ces actions). On fait appel à un objet par son nom sans guillemets. Les objets permettent de stocker des données, et prennent différentes formes. Les objets les plus courants sont les data frames et les vecteurs, mais il en existe d’autres, comme les listes et les matrices.\r\npackage : un ensemble de fonctions qui apportent des fonctionnalités supplémentaires à R. De nombreux packages sont inclus dans R, d’autres peuvent être téléchargés pour des besoins spécifiques.\r\nrépertoire de travail : le dossier sur votre ordinateur associé à votre session R actuelle, contenant les données que vous allez importer et où vous sauvegarderez des fichiers. Vous pouvez le définir au début de votre session à l’aide de la fonction setwd().\r\nscript : comme un éditeur de texte, un script vous permet d’écrire votre code et de le sauvegarder pour des usages futurs. Il contient un mélange de code et de commentaires et est sauvegardé comme un simple fichier texte que vous pouvez aisément partager pour que n’importe qui puisse reproduire votre travail.\r\nvecteur : un type d’objet R qui ne contient qu’une seule dimension : il stocke une ligne de valeurs qui peuvent être des caractères, des nombres, etc.\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/premiers-pas-avec-r/img/happy-r.png",
    "last_modified": "2022-06-09T15:51:28+02:00",
    "input_file": {}
  }
]
